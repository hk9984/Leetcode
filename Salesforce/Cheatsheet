Qs. Minimum operations to reduce integer to 0
i.p : n = 39, o/p: 3 (39 -> 7 -> -1 -> 0) 3 operations

Solution:
int ops = 0;
while(n!= 0) : 
    int lowerPower = Integer.highestOneBit(n);  //this method will return a number perfect power of 2 <= n
    // The idea is if n = 11001 , then Integer.highestOneBit means making the highest 1 bit and rest 0. Hence, for n = 11001 (25), Integer.highestOneBit = 10000 (16)
    int higherPower = lowerPower << 1; //this means shifting bits to one left position. This will mean number * 2
    // If lowerPower was 10000 (16) , then higherPower would be bits left shifted by 1 i.e. 100000 (32) which is also 16 * 2
    
    //next steop, abs subtract the original n with either lowerPower and higherPower, and check which is closer. Which ever is closer, take that difference and assign it to n
    // Every operation, do ops++. Do it till n becomes 0;
    int closerPower = Math.abs(n - power) > Math.abs(n - higherPower) ? higherPower : power;
    n = Math.abs(n - closerPower);
    ops++;

return ops;